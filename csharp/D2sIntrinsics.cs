using System.Runtime.CompilerServices;

namespace Ryu
{
    partial class Global // D2sIntrinsics
    {

#if HAS_64_BIT_INTRINSICS
         
static inline ulong umul128(ulong a, ulong b, ulong* productHi) {
  return _umul128(a, b, productHi);
}

static inline ulong shiftright128(ulong lo, ulong hi, uint dist) {
  // For the __shiftright128 intrinsic, the shift value is always
  // modulo 64.
  // In the current implementation of the double-precision version
  // of Ryu, the shift value is always < 64. (In the case
  // RYU_OPTIMIZE_SIZE == 0, the shift value is in the range [49, 58].
  // Otherwise in the range [2, 59].)
  // Check this here in case a future change requires larger shift
  // values. In this case this function needs to be adjusted.
  assert(dist < 64);
  return __shiftright128(lo, hi, (unsigned sbyte) dist);
}

#else // defined(HAS_64_BIT_INTRINSICS)

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static unsafe ulong umul128(ulong a, ulong b, ulong* productHi)
        {
            // The casts here help MSVC to avoid calls to the __allmul library function.
            uint aLo = (uint)a;
            uint aHi = (uint)(a >> 32);
            uint bLo = (uint)b;
            uint bHi = (uint)(b >> 32);

            ulong b00 = (ulong)aLo * bLo;
            ulong b01 = (ulong)aLo * bHi;
            ulong b10 = (ulong)aHi * bLo;
            ulong b11 = (ulong)aHi * bHi;

            uint b00Lo = (uint)b00;
            uint b00Hi = (uint)(b00 >> 32);

            ulong mid1 = b10 + b00Hi;
            uint mid1Lo = (uint)(mid1);
            uint mid1Hi = (uint)(mid1 >> 32);

            ulong mid2 = b01 + mid1Lo;
            uint mid2Lo = (uint)(mid2);
            uint mid2Hi = (uint)(mid2 >> 32);

            ulong pHi = b11 + mid1Hi + mid2Hi;
            ulong pLo = ((ulong)mid2Lo << 32) + b00Lo;

            *productHi = pHi;
            return pLo;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static ulong shiftright128(ulong lo, ulong hi, int dist)
        {
            // We don't need to handle the case dist >= 64 here (see above).
#if RYU_OPTIMIZE_SIZE || !RYU_32_BIT_PLATFORM
            return (hi << (64 - dist)) | (lo >> dist);
#else
        // Avoid a 64-bit shift by taking advantage of the range of shift values.
        assert(dist >= 32);
        return (hi << (64 - dist)) | ((uint)(lo >> 32) >> (dist - 32));
#endif
        }

#endif // defined(HAS_64_BIT_INTRINSICS)

#if RYU_32_BIT_PLATFORM

    // Returns the high 64 bits of the 128-bit product of a and b.
    static inline ulong umulh(ulong a, ulong b)
    {
        // Reuse the umul128 implementation.
        // Optimizers will likely eliminate the instructions used to compute the
        // low part of the product.
        ulong hi;
        umul128(a, b, &hi);
        return hi;
    }

    // On 32-bit platforms, compilers typically generate calls to library
    // functions for 64-bit divisions, even if the divisor is a constant.
    //
    // E.g.:
    // https://bugs.llvm.org/show_bug.cgi?id=37932
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
    //
    // The functions here perform division-by-constant using multiplications
    // in the same way as 64-bit compilers would do.
    //
    // NB:
    // The multipliers and shift values are the ones generated by clang x64
    // for expressions like x/5, x/10, etc.

    static inline ulong div5(ulong x)
    {
        return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 2;
    }

    static inline ulong div10(ulong x)
    {
        return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 3;
    }

    static inline ulong div100(ulong x)
    {
        return umulh(x >> 2, 0x28F5C28F5C28F5C3u) >> 2;
    }

    static inline ulong div1e8(ulong x)
    {
        return umulh(x, 0xABCC77118461CEFDu) >> 26;
    }

#else // RYU_32_BIT_PLATFORM

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static ulong div5(ulong x)
        {
            return x / 5;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static ulong div10(ulong x)
        {
            return x / 10;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static ulong div100(ulong x)
        {
            return x / 100;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static ulong div1e8(ulong x)
        {
            return x / 100000000;
        }

#endif // RYU_32_BIT_PLATFORM

    }
}
