Imports System.Runtime.CompilerServices

Module D2sIntrinsics

#If HAS_64_BIT_INTRINSICS Then

Private inline Function umul128(a As ULong, b As ULong, productHi As ULong*) As ULong
  Return _umul128(a, b, productHi)
End Function

Private inline Function shiftright128(lo As ULong, hi As ULong, dist As UInteger) As ULong
  ' For the __shiftright128 intrinsic, the shift value is always
  ' modulo 64.
  ' In the current implementation of the double-precision version
  ' of Ryu, the shift value is always < 64. (In the case
  ' RYU_OPTIMIZE_SIZE == 0, the shift value is in the range [49, 58].
  ' Otherwise in the range [2, 59].)
  ' Check this here in case a future change requires larger shift
  ' values. In this case this function needs to be adjusted.
  assert(dist < 64)
  Return __shiftright128(lo, hi, (unsigned SByte) dist)
End Function

#Else ' defined(HAS_64_BIT_INTRINSICS)

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function umul128(a As ULong, b As ULong, ByRef productHi As ULong) As ULong
        ' The casts here help MSVC to avoid calls to the __allmul library function.
        Dim aLo As UInteger = CUInt(a)
        Dim aHi As UInteger = CUInt(a >> 32)
        Dim bLo As UInteger = CUInt(b)
        Dim bHi As UInteger = CUInt(b >> 32)

        Dim b00 As ULong = CULng(aLo) * bLo
        Dim b01 As ULong = CULng(aLo) * bHi
        Dim b10 As ULong = CULng(aHi) * bLo
        Dim b11 As ULong = CULng(aHi) * bHi

        Dim b00Lo As UInteger = CUInt(b00)
        Dim b00Hi As UInteger = CUInt(b00 >> 32)

        Dim mid1 As ULong = b10 + b00Hi
        Dim mid1Lo As UInteger = CUInt(mid1)
        Dim mid1Hi As UInteger = CUInt(mid1 >> 32)

        Dim mid2 As ULong = b01 + mid1Lo
        Dim mid2Lo As UInteger = CUInt(mid2)
        Dim mid2Hi As UInteger = CUInt(mid2 >> 32)

        Dim pHi As ULong = b11 + mid1Hi + mid2Hi
        Dim pLo As ULong = (CULng(mid2Lo) << 32) + b00Lo

        productHi = pHi
        Return pLo
    End Function

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function shiftright128(lo As ULong, hi As ULong, dist As Integer) As ULong
        ' We don't need to handle the case dist >= 64 here (see above).
#If RYU_OPTIMIZE_SIZE OrElse Not RYU_32_BIT_PLATFORM Then
        Return (hi << (64 - dist)) Or (lo >> dist)
#Else
		' Avoid a 64-bit shift by taking advantage of the range of shift values.
		assert(dist >= 32)
		Return (hi << (64 - dist)) Or (CUInt(lo >> 32) >> (dist - 32))
#End If
    End Function

#End If ' defined(HAS_64_BIT_INTRINSICS)

#If RYU_32_BIT_PLATFORM Then

	' Returns the high 64 bits of the 128-bit product of a and b.
	Private inline Function umulh(a As ULong, b As ULong) As ULong
		' Reuse the umul128 implementation.
		' Optimizers will likely eliminate the instructions used to compute the
		' low part of the product.
		Dim hi As ULong
		umul128(a, b, &hi)
		Return hi
	End Function

	' On 32-bit platforms, compilers typically generate calls to library
	' functions for 64-bit divisions, even if the divisor is a constant.
	'
	' E.g.:
	' https://bugs.llvm.org/show_bug.cgi?id=37932
	' https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
	' https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
	'
	' The functions here perform division-by-constant using multiplications
	' in the same way as 64-bit compilers would do.
	'
	' NB:
	' The multipliers and shift values are the ones generated by clang x64
	' for expressions like x/5, x/10, etc.

	Private inline Function div5(x As ULong) As ULong
		Return umulh(x, &HCCCCCCCCCCCCCCCDUI) >> 2
	End Function

	Private inline Function div10(x As ULong) As ULong
		Return umulh(x, &HCCCCCCCCCCCCCCCDUI) >> 3
	End Function

	Private inline Function div100(x As ULong) As ULong
		Return umulh(x >> 2, &H28F5C28F5C28F5C3UI) >> 2
	End Function

	Private inline Function div1e8(x As ULong) As ULong
		Return umulh(x, &HABCC77118461CEFDUI) >> 26
	End Function

#Else ' RYU_32_BIT_PLATFORM

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function div5(x As ULong) As ULong
        Return x \ 5UL
    End Function

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function div10(x As ULong) As ULong
        Return x \ 10UL
    End Function

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function div100(x As ULong) As ULong
        Return x \ 100UL
    End Function

    <MethodImpl(MethodImplOptions.AggressiveInlining)>
    Function div1e8(x As ULong) As ULong
        Return x \ 100000000UL
    End Function

#End If ' RYU_32_BIT_PLATFORM

End Module
